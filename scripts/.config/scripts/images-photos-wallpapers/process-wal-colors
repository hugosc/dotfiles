#!/usr/bin/env python3
"""
Optimized script that combines color darkening and template regeneration.
This reduces file I/O by processing everything in a single pass.
"""

import colorsys
import json
import re
import sys
from pathlib import Path
from typing import Dict, Tuple


def hex_to_hsl(hex_color: str) -> Tuple[float, float, float]:
    """Convert hex color to HSL."""
    hex_color = hex_color.lstrip("#")
    r, g, b = tuple(int(hex_color[i : i + 2], 16) / 255.0 for i in (0, 2, 4))
    h, l, s = colorsys.rgb_to_hls(r, g, b)
    return h, l, s


def hsl_to_hex(h: float, l: float, s: float) -> str:
    """Convert HSL to hex color."""
    r, g, b = colorsys.hls_to_rgb(h, l, s)
    return "#{:02x}{:02x}{:02x}".format(int(r * 255), int(g * 255), int(b * 255))


def darken_color(color_hex: str, lightness_reduction: float) -> str:
    """Darken a color by reducing lightness uniformly."""
    h, l, s = hex_to_hsl(color_hex)
    new_l = max(0.0, l - lightness_reduction)
    return hsl_to_hex(h, new_l, s)


def enrich_color0(
    color_hex: str, lightness_reduction: float, saturation_increase: float
) -> str:
    """Darken a color AND add saturation for richness (used for color0/background)."""
    h, l, s = hex_to_hsl(color_hex)
    new_l = max(0.0, l - lightness_reduction)
    new_s = min(0.8, s + saturation_increase)
    return hsl_to_hex(h, new_l, new_s)


def process_colors(
    data: dict,
    lightness_reduction: float,
    saturation_increase: float,
    other_lightness_reduction: float,
    other_saturation_increase: float,
) -> Dict[str, str]:
    """Process and darken colors, returning a mapping of old to new colors."""
    darkened_colors_map = {}

    # Darken colors in the colors dict
    if "colors" in data:
        for key in data["colors"]:
            original_color = data["colors"][key]
            if key == "color0":
                darkened_color = enrich_color0(
                    original_color, lightness_reduction, saturation_increase
                )
            else:
                darkened_color = enrich_color0(
                    original_color, other_lightness_reduction, other_saturation_increase
                )
            darkened_colors_map[original_color] = darkened_color
            data["colors"][key] = darkened_color

    # Darken special colors
    if "special" in data:
        for key in data["special"]:
            original_color = data["special"][key]
            if key == "background":
                darkened_color = enrich_color0(
                    original_color, lightness_reduction, saturation_increase
                )
            else:
                darkened_color = enrich_color0(
                    original_color, other_lightness_reduction, other_saturation_increase
                )
            darkened_colors_map[original_color] = darkened_color
            data["special"][key] = darkened_color

    return darkened_colors_map


def apply_color_map(content: str, color_map: Dict[str, str]) -> str:
    """Apply color mapping to content using compiled regex for performance."""
    for old_color, new_color in color_map.items():
        # Use raw string replacement for simple case-insensitive replacement
        content = re.sub(re.escape(old_color), new_color, content, flags=re.IGNORECASE)
    return content


def generate_shell_colors(data: dict) -> str:
    """Generate shell colors configuration."""
    special = data.get("special", {})
    colors = data.get("colors", {})
    wallpaper = data.get("wallpaper", "")

    return f"""# Shell variables
# Generated by 'wal'
wallpaper='{wallpaper}'

# Special
background='{special.get("background", "#000000")}'
foreground='{special.get("foreground", "#ffffff")}'
cursor='{special.get("cursor", "#ffffff")}'

# Colors
color0='{colors.get("color0", "#000000")}'
color1='{colors.get("color1", "#000000")}'
color2='{colors.get("color2", "#000000")}'
color3='{colors.get("color3", "#000000")}'
color4='{colors.get("color4", "#000000")}'
color5='{colors.get("color5", "#000000")}'
color6='{colors.get("color6", "#000000")}'
color7='{colors.get("color7", "#000000")}'
color8='{colors.get("color8", "#000000")}'
color9='{colors.get("color9", "#000000")}'
color10='{colors.get("color10", "#000000")}'
color11='{colors.get("color11", "#000000")}'
color12='{colors.get("color12", "#000000")}'
color13='{colors.get("color13", "#000000")}'
color14='{colors.get("color14", "#000000")}'
color15='{colors.get("color15", "#000000")}'

# FZF colors
export FZF_DEFAULT_OPTS="
    $FZF_DEFAULT_OPTS
    --color fg:7,bg:0,hl:1,fg+:232,bg+:1,hl+:255
    --color info:7,prompt:2,spinner:1,pointer:232,marker:1
"

# Fix LS_COLORS being unreadable.
export LS_COLORS="${{LS_COLORS}}:su=30;41:ow=30;42:st=30;44:"
"""


def generate_kitty_config(data: dict) -> str:
    """Generate kitty configuration."""
    special = data.get("special", {})
    colors = data.get("colors", {})

    return f"""foreground   {special.get("foreground", "#ffffff")}
background   {special.get("background", "#000000")}
cursor       {special.get("cursor", "#ffffff")}

color0       {colors.get("color0", "#000000")}
color8       {colors.get("color8", "#808080")}
color1       {colors.get("color1", "#ff0000")}
color9       {colors.get("color9", "#ff0000")}
color2       {colors.get("color2", "#00ff00")}
color10      {colors.get("color10", "#00ff00")}
color3       {colors.get("color3", "#ffff00")}
color11      {colors.get("color11", "#ffff00")}
color4       {colors.get("color4", "#0000ff")}
color12      {colors.get("color12", "#0000ff")}
color5       {colors.get("color5", "#ff00ff")}
color13      {colors.get("color13", "#ff00ff")}
color6       {colors.get("color6", "#00ffff")}
color14      {colors.get("color14", "#00ffff")}
color7       {colors.get("color7", "#ffffff")}
color15      {colors.get("color15", "#ffffff")}
"""


def process_template(template_path: Path, data: dict) -> str:
    """Process a single template file."""
    with open(template_path) as f:
        content = f.read()

    colors = data.get("colors", {})
    special = data.get("special", {})
    wallpaper = data.get("wallpaper", "")

    # Replace color variables
    for key, value in colors.items():
        content = content.replace(f"{{{key}}}", value)

    # Replace special variables
    for key, value in special.items():
        content = content.replace(f"{{{key}}}", value)

    # Replace wallpaper
    content = content.replace("{wallpaper}", wallpaper)

    return content


def main():
    cache_dir = Path.home() / ".cache" / "wal"
    templates_dir = Path.home() / ".config" / "wal" / "templates"
    colors_json_file = cache_dir / "colors.json"

    # Parse arguments with minimum values of 0
    lightness_reduction = float(sys.argv[1]) if len(sys.argv) > 1 else 0.0
    saturation_increase = float(sys.argv[2]) if len(sys.argv) > 2 else 0.0
    other_lightness_reduction = float(sys.argv[3]) if len(sys.argv) > 3 else 0.0
    other_saturation_increase = float(sys.argv[4]) if len(sys.argv) > 4 else 0.0

    # Read colors.json once
    with open(colors_json_file) as f:
        data = json.load(f)

    # Process colors and get mapping
    color_map = process_colors(
        data,
        lightness_reduction,
        saturation_increase,
        other_lightness_reduction,
        other_saturation_increase,
    )

    # Write darkened colors.json once
    with open(colors_json_file, "w") as f:
        json.dump(data, f, indent=2)

    # Process all existing wal files with color mapping
    files_to_update = [
        cache_dir / "sequences",
        cache_dir / "colors.Xresources",
        cache_dir / "colors-wal.vim",
    ]

    for file_path in files_to_update:
        if file_path.exists():
            with open(file_path) as f:
                content = f.read()
            content = apply_color_map(content, color_map)
            with open(file_path, "w") as f:
                f.write(content)

    # Generate shell colors
    shell_content = generate_shell_colors(data)
    with open(cache_dir / "colors.sh", "w") as f:
        f.write(shell_content)

    # Generate kitty config
    kitty_content = generate_kitty_config(data)
    with open(cache_dir / "colors-kitty.conf", "w") as f:
        f.write(kitty_content)

    # Process templates
    if templates_dir.exists():
        for template_file in templates_dir.glob("*"):
            if template_file.is_file():
                content = process_template(template_file, data)
                output_file = cache_dir / template_file.name
                with open(output_file, "w") as f:
                    f.write(content)

    return 0


if __name__ == "__main__":
    sys.exit(main())
