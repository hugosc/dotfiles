#!/usr/bin/env bash

# Lightweight screen recording with hardware H.264 + WebM conversion support
# Uses Intel VAAPI for minimal CPU load
# Records to MP4, converts to WebM offline

REC_DIR="${HOME}/Videos"
REC_FLAG="${HOME}/.cache/recording"
REC_GEOMETRY="${HOME}/.cache/rec_geometry"

mkdir -p "$REC_DIR" "$HOME/.cache"

is_recording() {
	[[ -f "$REC_FLAG" ]]
}

get_timestamp() {
	date '+%Y%m%d_%H%M%S'
}

start_recording() {
	if is_recording; then
		echo "Already recording"
		exit 1
	fi
	
	# Clean up any orphaned ffmpeg screen recording processes
	pkill -INT -f "ffmpeg -vaapi_device.*screenrecord_" 2>/dev/null
	sleep 0.5
	pkill -9 -f "ffmpeg -vaapi_device.*screenrecord_" 2>/dev/null

	# Get screen geometry - extract just WxH
	# xrandr output: "1920x1080+0+0" -> we need "1920x1080"
	full_geometry=$(xrandr | grep " connected primary" | grep -oE '[0-9]+x[0-9]+\+[0-9]+\+[0-9]+')
	geometry=$(echo "$full_geometry" | cut -d+ -f1)
	
	# Fallback if that fails
	if [[ -z "$geometry" ]]; then
		geometry=$(xdotool getdisplaygeometry | awk '{print $1"x"$2}')
	fi
	
	# Save geometry for reference
	echo "$geometry" > "$REC_GEOMETRY"

	timestamp=$(get_timestamp)
	output="${REC_DIR}/screenrecord_${timestamp}.mp4"
	
	# Create flag file to indicate recording is active
	touch "$REC_FLAG"
	
	# Save output path for later use
	echo "$output" > "${REC_FLAG}.output"
	
	# Hardware H.264 recording (VAAPI) — ~5-10% CPU on i7-8550U
	# Options:
	#  -qp 26    : Quality (18-28, lower=better, 26 is good balance)
	#  -rc vbr   : Variable bitrate for better compression
	#  -r 30     : Framerate (change to 20 for even lighter)
	ffmpeg -vaapi_device /dev/dri/renderD128 \
		-f x11grab \
		-framerate 30 \
		-s "$geometry" \
		-i "$DISPLAY" \
		-f pulse \
		-i alsa_input.pci-0000_00_1f.3.analog-stereo \
		-vf 'format=nv12,hwupload' \
		-c:v h264_vaapi \
		-qp 26 \
		-rc vbr \
		-c:a aac \
		-q:a 4 \
		-y "$output" \
		>/dev/null 2>&1 &
	
	# Save the PID for stopping later
	echo $! > "${REC_FLAG}.pid"
	
	# Signal dwmblocks to update (signal 12 for screenrecord block)
	pkill -RTMIN+2 dwmblocks
}

stop_recording() {
	if ! is_recording; then
		echo "Not recording"
		exit 1
	fi

	# Get the ffmpeg process ID and output file
	pid=$(cat "${REC_FLAG}.pid" 2>/dev/null)
	output=$(cat "${REC_FLAG}.output" 2>/dev/null)
	
	if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
		# Send SIGINT to ffmpeg to gracefully finish encoding
		kill -INT "$pid" 2>/dev/null
		
		# Wait for process to finish (with timeout)
		for i in {1..10}; do
			kill -0 "$pid" 2>/dev/null || break
			sleep 0.5
		done
		
		# If still running, force kill
		kill -0 "$pid" 2>/dev/null && kill -9 "$pid" 2>/dev/null
	else
		# Fallback: PID is stale/missing, find and kill by output filename
		if [[ -n "$output" ]]; then
			# Use SIGINT for graceful shutdown
			pkill -INT -f "ffmpeg.*$output" 2>/dev/null
			sleep 2
			# Force kill if still running
			pkill -9 -f "ffmpeg.*$output" 2>/dev/null
		fi
	fi
	
	# Remove flag files
	rm -f "$REC_FLAG" "${REC_FLAG}.pid" "${REC_FLAG}.output" "$REC_GEOMETRY"
	
	# Give time for file to be written
	sleep 1
	
	# Signal dwmblocks to update (signal 12 for screenrecord block)
	pkill -RTMIN+2 dwmblocks
	
	# Copy file URI to clipboard like file managers do (text/uri-list format)
	# This allows pasting into Discord as if drag-dropping from a file manager
	if [[ -n "$output" && -f "$output" ]]; then
		file_uri="file://${output}"
		echo -n "$file_uri" | xclip -selection clipboard -t text/uri-list -i
		filename=$(basename "$output")
		notify-send --urgency=normal "Recording stopped" "$filename (copied to clipboard)"
		
		# Queue WebM conversion in background (low priority)
		# Conversion will happen in the background without blocking
		webm_output="${output%.*}.webm"
		if [[ ! -f "$webm_output" ]]; then
			(
				sleep 2  # Give file a moment to fully flush to disk
				nice -n 10 ionice -c3 ~/.config/scripts/audio-video/webm-convert "$output" 2>&1 | \
					while IFS= read -r line; do
						# Log conversion progress to syslog (optional, for debugging)
						logger -t screenrecord-convert "$line"
					done
				# When conversion is done, copy WebM to clipboard and notify
				if [[ -f "$webm_output" ]]; then
					webm_uri="file://${webm_output}"
					echo -n "$webm_uri" | xclip -selection clipboard -t text/uri-list -i
					webm_filename=$(basename "$webm_output")
					notify-send --urgency=normal "WebM ready" "$webm_filename (copied to clipboard)"
				fi
			) &
		fi
	fi
}

status() {
	if is_recording; then
		# Show recording indicator
		echo "●"
	else
		# Return empty for dwmblocks when not recording
		return 1
	fi
}

toggle_recording() {
	if is_recording; then
		stop_recording
	else
		start_recording
	fi
}

case "$1" in
	start)   start_recording ;;
	stop)    stop_recording ;;
	status)  status ;;
	toggle)  toggle_recording ;;
	*)
		cat << EOF
Usage: $0 <command>

Commands:
  start    - Start screen recording (hardware H.264, ~5-10% CPU)
  stop     - Stop and save recording
  toggle   - Toggle recording on/off
  status   - Show recording status

Examples:
  $0 toggle
  $0 status
EOF
		exit 1
		;;
esac
