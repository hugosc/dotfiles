#!/usr/bin/env bash
# Cliphist image history viewer with ueberzug++ previews
# Usage: cliphist-images-preview
# Launch in st for best results with wal colors

export DISPLAY="${DISPLAY:-:0}"
HELPER="/home/croc/.config/scripts/shortcuts-menus/cliphist-helper"
PREVIEW_WRAPPER="/home/croc/.config/scripts/shortcuts-menus/cliphist-preview-wrapper"

# Check dependencies
for cmd in ueberzugpp fzf xclip; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        echo "Error: $cmd not found" >&2
        read -p "Press Enter to exit..."
        exit 1
    fi
done

# ueberzugpp setup
case "$(uname -a)" in
    *Darwin*) UEBERZUG_TMP_DIR="$TMPDIR" ;;
    *) UEBERZUG_TMP_DIR="/tmp" ;;
esac

# Clean up stale ueberzugpp files (only if processes don't exist)
for pidfile in "$UEBERZUG_TMP_DIR"/.*-*-*-*-*; do
    [[ -f "$pidfile" ]] || continue
    pid=$(cat "$pidfile" 2>/dev/null)
    if [[ -n "$pid" ]] && ! kill -0 "$pid" 2>/dev/null; then
        rm -f "$pidfile" "$UEBERZUG_TMP_DIR/ueberzugpp-$pid.socket" 2>/dev/null
    fi
done

# Work directory for decoded images
WORK_DIR=$(mktemp -d -t cliphist-preview.XXXXXX)

cleanup() {
    [[ -n "${SOCKET:-}" ]] && ueberzugpp cmd -s "$SOCKET" -a exit 2>/dev/null || true
    [[ -n "${UB_PID_FILE:-}" ]] && rm -f "$UB_PID_FILE" 2>/dev/null || true
    [[ -n "${WORK_DIR:-}" ]] && rm -rf "$WORK_DIR"
}
trap cleanup HUP INT QUIT TERM EXIT

UB_PID_FILE="$UEBERZUG_TMP_DIR/.$(uuidgen)"
ueberzugpp layer --no-stdin --silent --pid-file "$UB_PID_FILE" 2>/dev/null &
sleep 0.2
UB_PID=$(cat "$UB_PID_FILE" 2>/dev/null || echo "")
if [[ -z "$UB_PID" ]]; then
    echo "Error: Failed to start ueberzugpp" >&2
    read -p "Press Enter to exit..."
    exit 1
fi
export SOCKET="$UEBERZUG_TMP_DIR"/ueberzugpp-"$UB_PID".socket

# Generate image list from ~/.cache/hist/
# Format: filepath<tab>display_name<tab>original_preview<tab>file_path
generate_image_list() {
    local counter=1
    
    HIST_DIR=~/.cache/hist
    if [[ ! -d "$HIST_DIR" ]]; then
        return
    fi
    
    find "$HIST_DIR" -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" \) -printf "%T@ %p\n" 2>/dev/null | \
    sort -rn | cut -d' ' -f2- | while read -r img_path; do
        if [[ -f "$img_path" ]]; then
            # Get image info
            img_info=$(file "$img_path" 2>/dev/null | grep -oP '\d+\s*x\s*\d+' | tr -d ' ' || echo "unknown")
            img_size=$(du -h "$img_path" 2>/dev/null | cut -f1 || echo "?")
            img_name=$(basename "$img_path")
            
            # Create display name - Format: "#N · WxH · SIZE"
            display_name=$(printf "#%-3d · %-10s · %-8s" "$counter" "$img_info" "$img_size")
            
            # Add type hints based on properties
            if [[ "$img_info" =~ ^(1920x1080|2560x1440|3840x2160|1366x768|1280x720)$ ]]; then
                display_name+=" · screenshot"
            elif [[ "$img_size" =~ ^[0-9]+K$ ]] && (( $(echo "$img_size" | grep -oP '\d+') < 500 )); then
                display_name+=" · graphic"
            elif [[ "$img_size" =~ M|G ]]; then
                display_name+=" · photo"
            fi
            
            # Output: filepath<tab>display_name<tab>original_preview<tab>file_path
            printf "HIST:%s\t%s\t%s\t%s\n" "$img_path" "$display_name" "$img_name" "$img_path"
            ((counter++))
        fi
    done
}

# Generate image list (instant - no decoding)
IMAGE_LIST=$(generate_image_list)

if [[ -z "$IMAGE_LIST" ]]; then
    echo "No images in clipboard history"
    read -p "Press Enter to exit..."
    exit 0
fi

# Create a temporary lookup file for fzf to access full lines
LOOKUP_FILE="$WORK_DIR/lookup.txt"
echo "$IMAGE_LIST" > "$LOOKUP_FILE"

# fzf with ueberzug++ preview using helper scripts
# {} contains the displayed text (field 2), use it to grep the full line
selected=$(echo "$IMAGE_LIST" | fzf \
    --with-nth=2 \
    --delimiter=$'\t' \
    --bind="enter:execute-silent(grep -F {} $LOOKUP_FILE | head -1 | xargs -I@ $HELPER copy @)+accept" \
    --bind="ctrl-c:execute-silent(grep -F {} $LOOKUP_FILE | head -1 | xargs -I@ $HELPER copy @)+accept" \
    --bind="ctrl-d:execute-silent(grep -F {} $LOOKUP_FILE | head -1 | xargs -I@ $HELPER delete @)+reload(bash -c 'export DISPLAY=:0 WORK_DIR=$WORK_DIR; counter=1; HIST_DIR=~/.cache/hist; [[ -d \"\$HIST_DIR\" ]] && find \"\$HIST_DIR\" -type f \\( -iname \"*.png\" -o -iname \"*.jpg\" -o -iname \"*.jpeg\" \\) -printf \"%T@ %p\\n\" 2>/dev/null | sort -rn | cut -d\" \" -f2- | while read -r img_path; do [[ -f \"\$img_path\" ]] || continue; img_info=\$(file \"\$img_path\" 2>/dev/null | grep -oP \"\\d+\\s*x\\s*\\d+\" | tr -d \" \" || echo \"unknown\"); img_size=\$(du -h \"\$img_path\" 2>/dev/null | cut -f1 || echo \"?\"); img_name=\$(basename \"\$img_path\"); display_name=\$(printf \"#%-3d · %-10s · %-8s\" \"\$counter\" \"\$img_info\" \"\$img_size\"); [[ \"\$img_info\" =~ ^(1920x1080|2560x1440|3840x2160|1366x768|1280x720)\$ ]] && display_name+=\" · screenshot\"; [[ \"\$img_size\" =~ ^[0-9]+K\$ ]] && (( \$(echo \"\$img_size\" | grep -oP \"\\d+\") < 500 )) && display_name+=\" · graphic\"; [[ \"\$img_size\" =~ M|G ]] && display_name+=\" · photo\"; printf \"HIST:%s\\t%s\\t%s\\t%s\\n\" \"\$img_path\" \"\$display_name\" \"\$img_name\" \"\$img_path\"; ((counter++)); done | tee $LOOKUP_FILE')" \
    --bind="ctrl-g:become(grep -F {} $LOOKUP_FILE | head -1 | xargs -I@ $HELPER gimp @)" \
    --style full \
    --reverse \
    --preview-border \
    --preview-label='[enter/*c*opy  *d*elete  *g*imp]' \
    --header='Clipboard Image History' \
    --preview="grep -F {} $LOOKUP_FILE | head -1 | xargs -I@ $PREVIEW_WRAPPER @ $SOCKET" || true)

# Show final notification only if something was selected
if [[ -n "$selected" ]]; then
    notify-send -u low "Clipboard" "Image copied to clipboard" 2>/dev/null || true
fi

# Explicit cleanup
cleanup
exit 0
